#!/usr/local/bin/python

import re
import socket
import subprocess
import sys
import telnetlib

zabbix_sender = "/usr/local/bin/zabbix_sender"
zabbix_conf = "<%= @conf_file %>"
zabbix_data = {}
base_key = "openvpn."

indicators = {
    'TUN/TAP read bytes': 'tun_read_bytes',
    'TUN/TAP write bytes': 'tun_write_bytes',
    'TCP/UDP read bytes': 'tcpudp_read_bytes',
    'TCP/UDP write bytes': 'tcpudp_write_bytes'
#    'Auth read bytes': 'auth_read_bytes',
#    'pre-compress bytes': 'pre_compress_bytes',
#    'post-compress bytes': 'post_compress_bytes',
#    'pre-decompress bytes': 'pre_decompress_bytes',
#    'post-decompress bytes': 'post_decompress_bytes'
}


def do_telnet(port, command):
  tn = telnetlib.Telnet('localhost', port)
  tn.read_until('for more info')
  tn.write(command + '\n')
  raw = tn.read_until('END')
  tn.close()
  raw = raw.strip('\r')
  raw = raw.strip('END')
  return raw.strip('\r')

#TODO: if we get more than one client this'll break
#state == '\n1354292685,ASSIGN_IP,,10.8.1.3,\n'
def get_state(port):
  raw = do_telnet(port, 'state')
  state_list = raw.split(',')
  zabbix_data['state'] = state_list[1]
  
#1 OpenVPN STATISTICS
#2 Updated,Fri Nov 30 16:51:58 2012
#3 TUN/TAP read bytes,24479
#4 TUN/TAP write bytes,2242
#5 TCP/UDP read bytes,3252
#6 TCP/UDP write bytes,3808
#7 Auth read bytes,2275
#8 pre-compress bytes,2588
#9 post-compress bytes,2141
#10 pre-decompress bytes,725
#11 post-decompress bytes,903
#12 END
def get_status(port):
  raw = do_telnet(port, 'status')
  status_list = raw.split('\n')
  for status in status_list:
    if status.find(',') >= 0:
      n,val = status.split(',')
      if n in indicators:
        ind = indicators[n]
      	zabbix_data[ind] = val

def send_zabbix(tunnel_name):
  hostname = socket.gethostname().split('.')[0]
  data = ""
  for key in zabbix_data:
    full_key = base_key + tunnel_name + "." + key
    data = data + hostname + " " + full_key + " " + str(zabbix_data[key]) + "\n"

  print data
  z = subprocess.Popen([zabbix_sender, "-c", zabbix_conf, "-i", "-"], stdin=subprocess.PIPE)
  z.communicate(input=data)

  
def usage_and_die(mssg):
  print 'Invalid usage: ' + str(mssg)
  print sys.argv[0] + ' port tunnel_name'
  exit()

#main
if len(sys.argv) != 3:
  usage_and_die('Not enough args')

port = sys.argv[1]
get_state(port)
get_status(port)
send_zabbix(sys.argv[2])


